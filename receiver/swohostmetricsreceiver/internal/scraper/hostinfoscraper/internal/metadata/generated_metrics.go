// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
	conventions "go.opentelemetry.io/collector/semconv/v1.9.0"
)

type metricSwoHostinfoFirewall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills swo.hostinfo.firewall metric with initial data.
func (m *metricSwoHostinfoFirewall) init() {
	m.data.SetName("swo.hostinfo.firewall")
	m.data.SetDescription("Metric provides firewall profiles statuses. This metric is supported only on Windows.")
	m.data.SetUnit("status")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSwoHostinfoFirewall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, firewallProfileNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("firewall.profile.name", firewallProfileNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSwoHostinfoFirewall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSwoHostinfoFirewall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSwoHostinfoFirewall(cfg MetricConfig) metricSwoHostinfoFirewall {
	m := metricSwoHostinfoFirewall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSwoHostinfoUptime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills swo.hostinfo.uptime metric with initial data.
func (m *metricSwoHostinfoUptime) init() {
	m.data.SetName("swo.hostinfo.uptime")
	m.data.SetDescription("Host uptime in seconds.")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSwoHostinfoUptime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostdetailsDomainAttributeValue string, hostdetailsDomainFqdnAttributeValue string, hostdetailsDomainRoleAttributeValue int64, hostdetailsModelSerialnumberAttributeValue string, hostdetailsModelManufacturerAttributeValue string, hostdetailsModelNameAttributeValue string, hostdetailsTimezoneBiasAttributeValue int64, hostdetailsTimezoneCaptionAttributeValue string, hostdetailsTimezoneStandardnameAttributeValue string, osdetailsHostnameAttributeValue string, osdetailsBoottimeAttributeValue int64, osdetailsOsAttributeValue string, osdetailsPlatformAttributeValue string, osdetailsPlatformFamilyAttributeValue string, osdetailsPlatformVersionAttributeValue string, osdetailsKernelVersionAttributeValue string, osdetailsKernelArchitectureAttributeValue string, osdetailsVirtualizationSystemAttributeValue string, osdetailsVirtualizationRoleAttributeValue string, osdetailsHostIDAttributeValue string, osdetailsLanguageLcidAttributeValue int64, osdetailsLanguageNameAttributeValue string, osdetailsLanguageDisplaynameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostdetails.domain", hostdetailsDomainAttributeValue)
	dp.Attributes().PutStr("hostdetails.domain.fqdn", hostdetailsDomainFqdnAttributeValue)
	dp.Attributes().PutInt("hostdetails.domain.role", hostdetailsDomainRoleAttributeValue)
	dp.Attributes().PutStr("hostdetails.model.serialnumber", hostdetailsModelSerialnumberAttributeValue)
	dp.Attributes().PutStr("hostdetails.model.manufacturer", hostdetailsModelManufacturerAttributeValue)
	dp.Attributes().PutStr("hostdetails.model.name", hostdetailsModelNameAttributeValue)
	dp.Attributes().PutInt("hostdetails.timezone.bias", hostdetailsTimezoneBiasAttributeValue)
	dp.Attributes().PutStr("hostdetails.timezone.caption", hostdetailsTimezoneCaptionAttributeValue)
	dp.Attributes().PutStr("hostdetails.timezone.standardname", hostdetailsTimezoneStandardnameAttributeValue)
	dp.Attributes().PutStr("osdetails.hostname", osdetailsHostnameAttributeValue)
	dp.Attributes().PutInt("osdetails.boottime", osdetailsBoottimeAttributeValue)
	dp.Attributes().PutStr("osdetails.os", osdetailsOsAttributeValue)
	dp.Attributes().PutStr("osdetails.platform", osdetailsPlatformAttributeValue)
	dp.Attributes().PutStr("osdetails.platform.family", osdetailsPlatformFamilyAttributeValue)
	dp.Attributes().PutStr("osdetails.platform.version", osdetailsPlatformVersionAttributeValue)
	dp.Attributes().PutStr("osdetails.kernel.version", osdetailsKernelVersionAttributeValue)
	dp.Attributes().PutStr("osdetails.kernel.architecture", osdetailsKernelArchitectureAttributeValue)
	dp.Attributes().PutStr("osdetails.virtualization.system", osdetailsVirtualizationSystemAttributeValue)
	dp.Attributes().PutStr("osdetails.virtualization.role", osdetailsVirtualizationRoleAttributeValue)
	dp.Attributes().PutStr("osdetails.host.id", osdetailsHostIDAttributeValue)
	dp.Attributes().PutInt("osdetails.language.lcid", osdetailsLanguageLcidAttributeValue)
	dp.Attributes().PutStr("osdetails.language.name", osdetailsLanguageNameAttributeValue)
	dp.Attributes().PutStr("osdetails.language.displayname", osdetailsLanguageDisplaynameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSwoHostinfoUptime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSwoHostinfoUptime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSwoHostinfoUptime(cfg MetricConfig) metricSwoHostinfoUptime {
	m := metricSwoHostinfoUptime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSwoHostinfoUserLastLogged struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills swo.hostinfo.user.lastLogged metric with initial data.
func (m *metricSwoHostinfoUserLastLogged) init() {
	m.data.SetName("swo.hostinfo.user.lastLogged")
	m.data.SetDescription("Host last logged-in user. Supported for Windows and Linux.")
	m.data.SetUnit("user")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSwoHostinfoUserLastLogged) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, userNameAttributeValue string, userDisplaynameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("user.name", userNameAttributeValue)
	dp.Attributes().PutStr("user.displayname", userDisplaynameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSwoHostinfoUserLastLogged) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSwoHostinfoUserLastLogged) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSwoHostinfoUserLastLogged(cfg MetricConfig) metricSwoHostinfoUserLastLogged {
	m := metricSwoHostinfoUserLastLogged{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                          MetricsBuilderConfig // config of the metrics builder.
	startTime                       pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                 int                  // maximum observed number of metrics per resource.
	metricsBuffer                   pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                       component.BuildInfo  // contains version information.
	metricSwoHostinfoFirewall       metricSwoHostinfoFirewall
	metricSwoHostinfoUptime         metricSwoHostinfoUptime
	metricSwoHostinfoUserLastLogged metricSwoHostinfoUserLastLogged
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                          mbc,
		startTime:                       pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                   pmetric.NewMetrics(),
		buildInfo:                       settings.BuildInfo,
		metricSwoHostinfoFirewall:       newMetricSwoHostinfoFirewall(mbc.Metrics.SwoHostinfoFirewall),
		metricSwoHostinfoUptime:         newMetricSwoHostinfoUptime(mbc.Metrics.SwoHostinfoUptime),
		metricSwoHostinfoUserLastLogged: newMetricSwoHostinfoUserLastLogged(mbc.Metrics.SwoHostinfoUserLastLogged),
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.SetSchemaUrl(conventions.SchemaURL)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("github.com/solarwinds/solarwinds-otel-collector/receiver/swohostmetricsreceiver/internal/scraper/hostinfoscraper")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSwoHostinfoFirewall.emit(ils.Metrics())
	mb.metricSwoHostinfoUptime.emit(ils.Metrics())
	mb.metricSwoHostinfoUserLastLogged.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordSwoHostinfoFirewallDataPoint adds a data point to swo.hostinfo.firewall metric.
func (mb *MetricsBuilder) RecordSwoHostinfoFirewallDataPoint(ts pcommon.Timestamp, val int64, firewallProfileNameAttributeValue string) {
	mb.metricSwoHostinfoFirewall.recordDataPoint(mb.startTime, ts, val, firewallProfileNameAttributeValue)
}

// RecordSwoHostinfoUptimeDataPoint adds a data point to swo.hostinfo.uptime metric.
func (mb *MetricsBuilder) RecordSwoHostinfoUptimeDataPoint(ts pcommon.Timestamp, val int64, hostdetailsDomainAttributeValue string, hostdetailsDomainFqdnAttributeValue string, hostdetailsDomainRoleAttributeValue int64, hostdetailsModelSerialnumberAttributeValue string, hostdetailsModelManufacturerAttributeValue string, hostdetailsModelNameAttributeValue string, hostdetailsTimezoneBiasAttributeValue int64, hostdetailsTimezoneCaptionAttributeValue string, hostdetailsTimezoneStandardnameAttributeValue string, osdetailsHostnameAttributeValue string, osdetailsBoottimeAttributeValue int64, osdetailsOsAttributeValue string, osdetailsPlatformAttributeValue string, osdetailsPlatformFamilyAttributeValue string, osdetailsPlatformVersionAttributeValue string, osdetailsKernelVersionAttributeValue string, osdetailsKernelArchitectureAttributeValue string, osdetailsVirtualizationSystemAttributeValue string, osdetailsVirtualizationRoleAttributeValue string, osdetailsHostIDAttributeValue string, osdetailsLanguageLcidAttributeValue int64, osdetailsLanguageNameAttributeValue string, osdetailsLanguageDisplaynameAttributeValue string) {
	mb.metricSwoHostinfoUptime.recordDataPoint(mb.startTime, ts, val, hostdetailsDomainAttributeValue, hostdetailsDomainFqdnAttributeValue, hostdetailsDomainRoleAttributeValue, hostdetailsModelSerialnumberAttributeValue, hostdetailsModelManufacturerAttributeValue, hostdetailsModelNameAttributeValue, hostdetailsTimezoneBiasAttributeValue, hostdetailsTimezoneCaptionAttributeValue, hostdetailsTimezoneStandardnameAttributeValue, osdetailsHostnameAttributeValue, osdetailsBoottimeAttributeValue, osdetailsOsAttributeValue, osdetailsPlatformAttributeValue, osdetailsPlatformFamilyAttributeValue, osdetailsPlatformVersionAttributeValue, osdetailsKernelVersionAttributeValue, osdetailsKernelArchitectureAttributeValue, osdetailsVirtualizationSystemAttributeValue, osdetailsVirtualizationRoleAttributeValue, osdetailsHostIDAttributeValue, osdetailsLanguageLcidAttributeValue, osdetailsLanguageNameAttributeValue, osdetailsLanguageDisplaynameAttributeValue)
}

// RecordSwoHostinfoUserLastLoggedDataPoint adds a data point to swo.hostinfo.user.lastLogged metric.
func (mb *MetricsBuilder) RecordSwoHostinfoUserLastLoggedDataPoint(ts pcommon.Timestamp, val int64, userNameAttributeValue string, userDisplaynameAttributeValue string) {
	mb.metricSwoHostinfoUserLastLogged.recordDataPoint(mb.startTime, ts, val, userNameAttributeValue, userDisplaynameAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
